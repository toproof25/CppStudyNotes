# range-based for statement에서 복사와 참조 사용 비교
- [[CPP - 참조와 복사의 차이점 (CPU 동작 과정)]]을 작성하면서 for문에서 사용하는 경우는 또 다른가란 생각이 들었다
- 그래서 for문에서 vector를 사용할 때 작은 타입은 int와 double와 큰 타입 구조체 등에서 얼마나 실행 시간이 차이가 날 지 확인해봤다
- 우선 테스트 코드를 `g++ -S -O0 -o test_no_opt.s test.cpp`으로 어셈블리 코드를 만든 후 해당 코드를 확인해본다
- 일단 어셈블리에 대해서는 잘 모르니까 추출한 어셈블리를 Gemini, Chat GPT에게 분석해달라고 했다.


## 일반 타입에서 어셈블리

##### **복사를 사용한 일반 타입**
- 여기서 핵심은 복사할 공간을 할당하고, 복사한 후, 더하는 과정이다
	```
		; --- for 루프 본문 ---
	.L49:
		movq	-48(%rbp), %rax         ; 현재 iterator(__begin)의 값을 %rax에 로드
		movl	(%rax), %eax            ; iterator가 가리키는 주소의 실제 int 값을 읽음
		movl	%eax, -20(%rbp)         ; 🔥 핵심: 읽어온 값을 'v'를 위한 새 메모리(-20)에 '복사'
		movl	-20(%rbp), %eax         ; 복사된 'v'의 값을 다시 %eax에 로드
		addl	%eax, -4(%rbp)          ; sum += v; -> sum 변수에 v 값을 더함
		movq	-48(%rbp), %rax         ; 현재 iterator 값을 로드
		addq	$4, %rax                ; iterator를 4바이트(int 크기)만큼 증가시켜 다음 요소를 가리킴
		movq	%rax, -48(%rbp)         ; 증가된 iterator 값을 다시 저장
	```


##### **참조를 사용한 일반 타입**
- 참조의 경우 원본 주소를 저장하고, 원본 주소를 찾아가 값을 로드하고, 그 값을 더한다
	```
		; --- for 루프 본문 ---
	.L63:
		movq	-48(%rbp), %rax         ; 현재 iterator(__begin)의 값(원본 데이터의 주소)을 %rax에 로드
		movq	%rax, -24(%rbp)         ; 🔥 핵심: 'v'는 원본 데이터의 '주소' 자체를 값으로 가짐 (참조)
		movq	-24(%rbp), %rax         ; 참조 'v'가 가진 주소 값을 %rax에 로드
		movl	(%rax), %eax            ; 그 주소로 직접 가서 실제 int 값을 읽어옴
		addl	%eax, -4(%rbp)          ; sum += v; -> sum 변수에 v 값을 더함 (복사 과정 없음)
		movq	-48(%rbp), %rax         ; 현재 iterator 값을 로드
		addq	$4, %rax                ; iterator를 4바이트(int 크기)만큼 증가
		movq	%rax, -48(%rbp)         ; 증가된 iterator 값을 다시 저장
	```


##### 일반 타입 복사/참조 정리
- 사실 어셈블리를 잘 모르지만 대충 봐도 비슷하게 동작한다고 느껴진다. 실제로 크게 유의미한 차이가 없어서 int나 double같은 작은 타입의 경우에는 복사와 참조도 비슷한 거 같다
- 또한 컴파일러 최적화를 한 어셈블리 코드에서는 아예 없거나 매우 간단하게 표현될 수 있다고 한다


## 구조체 타입에서 어셈블리

##### **복사를 사용한 경우**
```  
    ; --- for 루프 본문 ---
.L92:
	movq	-40(%rbp), %rdx         ; 원본 객체의 주소(현재 iterator)를 %rdx에 로드
	leaq	-112(%rbp), %rax        ; 🔥 스택에 'v'를 위한 새로운 메모리 공간(-112) 주소를 준비
	movq	%rax, %rcx              ; 'v'의 주소를 첫 번째 인자로 설정 (this 포인터)
	call	_ZN4ABCDC1ERKS_         ; 🔥 핵심: ABCD의 '복사 생성자'를 호출. 모든 멤버(string 포함)의 깊은 복사가 여기서 발생
	movl	-112(%rbp), %eax        ; 복사된 'v'(-112)의 첫 멤버 'a'의 값을 읽음
	addl	%eax, -4(%rbp)          ; sum += v.a;
	leaq	-112(%rbp), %rax        ; 🔥 복사본 'v'의 주소를 다시 로드
	movq	%rax, %rcx              ;
	call	_ZN4ABCDD1Ev            ; 🔥 핵심: 루프 한번 돌고 'v'가 소멸하므로 '소멸자'를 호출
	movq	-40(%rbp), %rax         ; 현재 iterator 값을 로드
	addq	$56, %rax               ; iterator를 56바이트(ABCD 크기)만큼 증가
	movq	%rax, -40(%rbp)         ; 증가된 iterator 값을 저장
```
- 이 경우에는 구조체를 복사를 하는 과정이 나타난다. `call	_ZN4ABCDC1ERKS_`이 부분이 구조체의 복사 생성자가 호출이 되는 부분이며, 복사된 구조체에서 `addl`연산이 이루어진다
- 아래 부분이 핵심적인 부분으로 
	- `-112(%rbp), %rax` 복사된 값을 저장하기 위해 새로운 메모리 공간을 할당, rax라는 공간이 생성됨
	- `%rax, %rcx` rax공간을 사용하기로 지정
	- `_ZN4ABCDC1ERKS_` **해당 공간에 복사 생성자를 호출**
	- `-112(%rbp), %eax` 복사된 구조체의 a값을 읽음
	- `%eax, -4(%rbp)` sum += v.a 를 수행
	- 이후에는 소멸자도 호출됨... `call	_ZN4ABCDD1Ev`
	```
	leaq	-112(%rbp), %rax        ; 🔥 스택에 'v'를 위한 새로운 메모리 공간(-112) 주소를 준비
	movq	%rax, %rcx              ; 'v'의 주소를 첫 번째 인자로 설정 (this 포인터)
	call	_ZN4ABCDC1ERKS_         ; 🔥 핵심: ABCD의 '복사 생성자'를 호출. 모든 멤버(string 포함)의 깊은 복사가 여기서 발생
	movl	-112(%rbp), %eax        ; 복사된 'v'(-112)의 첫 멤버 'a'의 값을 읽음
	addl	%eax, -4(%rbp)          ; sum += v.a;
	```
- 위에서 `call	_ZN4ABCDC1ERKS_`인 구조체의 복사 생성자 부분이 호출되는데  아래의 코드가 실행이 된다
  
		```구조체의 복사 생성자
		_ZN4ABCDC1ERKS_:
		.LFB3110:
			pushq	%rbp                    ; 함수 시작, 스택 프레임 설정
			movq	%rsp, %rbp              ;
			subq	$32, %rsp               ; 이 함수를 위한 스택 공간 할당
			movq	%rcx, 16(%rbp)          ; 첫 번째 인자(destination의 주소)를 스택에 저장
			movq	%rdx, 24(%rbp)          ; 두 번째 인자(source의 주소)를 스택에 저장
		
		; --- 멤버 'a' (int) 복사 ---
			movq	24(%rbp), %rax          ; 원본(source)의 주소를 %rax 레지스터로 가져옴
			movl	(%rax), %edx            ; %rax가 가리키는 곳에서 4바이트(int a)를 읽어 %edx에 저장
			movq	16(%rbp), %rax          ; 대상(destination)의 주소를 %rax 레지스터로 가져옴
			movl	%edx, (%rax)            ; 대상의 메모리에 %edx 값을 씀 (this->a = source.a)
		
		; --- 멤버 'b' (double) 복사 ---
			movq	24(%rbp), %rax          ; 원본(source)의 주소를 가져옴
			movsd	8(%rax), %xmm0          ; 원본 주소+8바이트 위치에서 double b 값을 읽어 %xmm0(부동소수점 레지스터)에 저장
			movq	16(%rbp), %rax          ; 대상(destination)의 주소를 가져옴
			movsd	%xmm0, 8(%rax)          ; 대상 주소+8바이트 위치에 %xmm0 값을 씀 (this->b = source.b)
		
		; --- 멤버 'c' (char) 복사 ---
			movq	24(%rbp), %rax          ; 원본(source)의 주소를 가져옴
			movzbl	16(%rax), %edx          ; 원본 주소+16바이트 위치에서 1바이트(char c)를 읽어 %edx에 저장
			movq	16(%rbp), %rax          ; 대상(destination)의 주소를 가져옴
			movb	%dl, 16(%rax)           ; 대상 주소+16바이트 위치에 %edx의 하위 1바이트 값을 씀 (this->c = source.c)
		
		; --- 멤버 'd' (bool) 복사 ---
			movq	24(%rbp), %rax          ; 원본(source)의 주소를 가져옴
			movzbl	17(%rax), %edx          ; 원본 주소+17바이트 위치에서 1바이트(bool d)를 읽어 %edx에 저장
			movq	16(%rbp), %rax          ; 대상(destination)의 주소를 가져옴
			movb	%dl, 17(%rax)           ; 대상 주소+17바이트 위치에 값을 씀 (this->d = source.d)
		
		; --- 멤버 'e' (std::string) 복사 ---
			movq	16(%rbp), %rax          ; 대상(destination)의 주소를 가져옴
			addq	$24, %rax               ; 대상 주소+24바이트 위치, 즉 string e 멤버의 시작 주소를 계산
			movq	24(%rbp), %rdx          ; 원본(source)의 주소를 가져옴
			addq	$24, %rdx               ; 원본 주소+24바이트 위치, 즉 source의 string e 멤버 주소를 계산
			movq	%rax, %rcx              ; 대상 string의 주소를 첫 번째 인자로 설정
			call	_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEC1ERKS4_
		    ; 🔥 핵심: std::string의 복사 생성자를 호출!
		    ; 이 함수가 내부적으로 새로운 메모리를 할당하고 문자열 데이터를 복사하는
		    ; 모든 비싼 작업을 처리합니다.
		
			nop                             ; 아무 작업 안 함 (패딩)
			addq	$32, %rsp               ; 함수 종료, 할당했던 스택 공간 해제
			popq	%rbp                    ; 스택 프레임 복원
			ret                             ; 함수 호출 지점으로 복귀
		```



##### **참조를 사용한 경우**
```
    ; --- for 루프 본문 ---
.L101:
	movq	-48(%rbp), %rax         ; 현재 iterator의 값(원본 객체의 주소)을 %rax에 로드
	movq	%rax, -24(%rbp)         ; 🔥 핵심: 'v'는 원본 객체의 '주소' 자체를 값으로 가짐 (참조)
	movq	-24(%rbp), %rax         ; 참조 'v'가 가진 주소 값을 %rax에 로드
	movl	(%rax), %eax            ; 🔥 그 주소에서 바로 첫 멤버 'a'의 값을 읽어옴 (복사 없음!)
	addl	%eax, -4(%rbp)          ; sum += v.a;
	movq	-48(%rbp), %rax         ; 현재 iterator 값을 로드
	addq	$56, %rax               ; iterator를 56바이트(ABCD 크기)만큼 증가
	movq	%rax, -48(%rbp)         ; 증가된 iterator 값을 저장
```
- 참조는 간단하게 해당 주소에 값을 가져와서 더한다. 참조를 사용하기에 복사 과정이 발생하지 않는다
	- `%rax, -24(%rbp)` 복사와는 다르게 메모리 주소를 할당하지 않고, 원본 주소를 저장 `const ABCD& v` 부분
	- `-24(%rbp), %rax` 원본 주소를 사용하기 위해 저장
	- `(%rax), %eax` 원본 주소에 a값을 읽어옴
	- `%eax, -4(%rbp)` sum += v.a
	- 원본을 사용했기에 소멸자도 호출하지 않는다
	```
	movq	%rax, -24(%rbp)         ; 🔥 핵심: 'v'는 원본 객체의 '주소' 자체를 값으로 가짐 (참조)
	movq	-24(%rbp), %rax         ; 참조 'v'가 가진 주소 값을 %rax에 로드
	movl	(%rax), %eax            ; 🔥 그 주소에서 바로 첫 멤버 'a'의 값을 읽어옴 (복사 없음!)
	addl	%eax, -4(%rbp)          ; sum += v.a;
	```

##### 구조체 복사/참조 정리
- 복사와 참조 부분에서 가장 큰 차이점은 `call` 명령으로 복사 생성자 호출 되냐 안되냐의 차이였다. 
- 참조의 경우 바로 원본 주소에 접근해서 값을 가져오는 반면, 복사의 경우 복사 생성자 `_ZN4ABCDC1ERKS_`이 부분에서 모든 원소가 새로운 공간에 복사되고, 또 `string`같은 큰 데이터 또한 내부적으로 복사 생성자라 호출되고.... 그렇게 하나의 구조체가 복사되는 것과 참조의 차이가 발생하게 된다
- 고급 언어 C++ 코드에서는 단순하게 const와 &의 차이일 뿐이었는데 내부적으로 컴파일이 되면 이렇게 차이가 나는게 신기하기도 했으며, 컴퓨터 관점에서 더 이해가 되는 부분이었다



## 정리
- 나는 무조건적으로 참조를 사용하는게 좋고 효율적이라는 걸 봐서 별 생각 없이 그렇게 사용해왔다. 
- 사실 그 방법이 올바른 방향일지라도 원리를 이해하는 것과 모르고 사용하는건 큰 차이가 있다고 생각한다. 
- C++ 코드에서는 보이지 않던 부분을 볼 수 있어서 재미있었고, 별 거 아닌 것 같아도 이런 차이가 발생한다는게 신기했다. 
- 또 최적화라는게 이런 식으로 접근하다보면 정말 어렵고 난이도가 있는 작업이라는 것도 이해할 수 있었다
- 처리 시간 테스트를 했을 때에는 예상대로 참조의 결과가 더 좋게 나타났다. 일반 타입의 경우 상당한 반복 횟수를 했음에도 크게 차이가 나지 않았던 부분이 조금 놀라웠다
- 구조체의 경우에는 엄청난 차이가 발생하였으며, 1억번 반복했을 때는 오래걸려서 밥 먹고 왔더니 끝나있었다

- ### 테스트 결과
	- **실행 결과 각 1천만번**
		```
		int 타입 복사 방식 경과 시간 : 0.0166756 seconds
		int 타입 const 참조 방식 경과 시간 : 0.0165936 seconds
		----------------------------------------------------------------------------------------------
		double 타입 복사 방식 경과 시간 : 0.0207907 seconds
		double 타입 const 참조 방식 경과 시간 : 0.0210501 seconds
		----------------------------------------------------------------------------------------------
		구조체 타입 복사 방식 경과 시간 : 9.58186 seconds
		구조체 타입 const 참조 방식 경과 시간 : 0.0314313 seconds
		```
	
	- **실행 결과 반복 횟수 1억번** (오래걸려서 돌리고 밥 먹고 왔더니 결과가 나타났다...)
		- 반복 수가 엄청나게 크게 설정하니 그 차이가 엄청나게 나타났다
		```
		int 타입 복사 방식 경과 시간 : 0.192251 seconds
		int 타입 const 참조 방식 경과 시간 : 0.200222 seconds
		----------------------------------------------------------------------------------------------
		double 타입 복사 방식 경과 시간 : 0.281103 seconds
		double 타입 const 참조 방식 경과 시간 : 0.209386 seconds
		----------------------------------------------------------------------------------------------
		구조체 타입 복사 방식 경과 시간 : 1328.43 seconds
		구조체 타입 const 참조 방식 경과 시간 : 0.528859 seconds
		```


