# Chapter7 객체지향 프로그래밍 - 객체지향 프로그래밍 특징
1. 추상화, 캡슐화, 상속성, 다형성
2. 생성자와 소멸자
3. this 포인터
4. 함수와 연산자 오버로딩
5. 접근 지정자와 프렌드


### Abstraction (추상화)
- 추상화란 **객체의 공통적인 속성과 기능을 추출하여 정의하는 것**
>삼성 갤럭시와 애플 아이폰은 같은 "휴대폰"이라는 공통점이 있다.
>이 휴대폰의 카메라, 규격와 같은 속성과 문자, 전화와 같은 공통적인 속성과 기능을 추출하여 하나로 추상화 하는 것을 의미한다.
>그렇게 "휴대폰"이라는 클래스를 제작한 후 상속과 다형성을 이용하여 삼성만의 휴대폰, 애플만의 아이폰을 구현할 수 있다.
- 복잡성 감소
- 표준화
- 생산성

### Encapsulation (캡슐화)
- 캡슐화란 **속성과 기능을 하나로 묶어 외부에서 접근하지 못하게 보호하는 것**
>"갤럭시", "아이폰" 이라는 클래스를 만든 후 사용자는 내부적으로 어떤 CPU, RAM을 사용하고 어떤 구조로 전화를 받거나 문자를 보내는 지 알 수는 없다. 하지만 해당 "갤럭시", "아이폰"을 사용하여 기능을 사용할 수 있는 것.
>즉 문자를 보내는 기능을 예로 들면 상대방의 전화번호와 문자 텍스트만 입력한 후 버튼을 누르면 문자를 발송한다. 여기서 발송 버튼을 누르면 어떤 로직으로 발송되는 지는 모르지만 사용자는 그것을 몰라도 해당 기능을 사용할 수 있다. 사용자가 의도적으로 발송하는 알고리즘을 수정하거나 확인할 수 없이 캡슐화 되어있어 이 알고리즘은 보호를 받고 기능을 수행할 수 있는 것이다.
>이를 잘 활용하는 것이 접근 제어자(private, public)와 게터, 세터이다.
>접근 제어가 private필드에 작성된 변수 volume을 수정하고 값을 읽고자 할 때
>해당 변수에 대한 getter, setter 함수를 이용하여 사용할 수 있는 것. 


### Inheritance (상속)
- 상속은 **부모 클래스(혹은 기존 클래스)의 속성과 기능을 자식 클래스가 물려받는 것**
>기존 클래스에서 정의한 속성 혹은 기능을 새로운 클래스에서 다시 작성하지 않고, 해당 클래스를 상속받아 속성과 기능을 그대로 사용할 수 있다.
>"휴대폰"이라는 클래스에서 전화받기, 문자보내기와 같은 기능을 구현한 후
>"갤럭시"라는 클래스를 제작하고 "휴대폰"클래스를 상속받는다면, "갤럭시"클래스에서는 따로 전와받기, 문자보내기를 구현하지 않아도 기능을 사용할 수 있다.
>부모 클래스를 상속받는 자식 클래스는 부모 클래스로 취급할 수 있다는 관계
>갤럭시 is a  휴대폰 : 갤럭시는 휴대폰을 취급할 수 있다
>아이폰 is a 휴대폰 : 마찬가지로 아이폰은 휴대폰을 취급할 수 있다.
>즉 자식 클래스는 부모 클래스의 특징을 물려받았기에 부모 클래스로 취급할 수 있는 것

#### 상속 접근 지정자
- `class test : base`
- 위처럼 상속을 할 때 접근 지정자를 지정하지 않으면 기본적으로 `private`로 지정된다.
- 자식 클래스에서는 상속 접근 지정자에 따라 부모의 public, protected 지정자는 protected, private로 변경된다. 그렇기 때문에 protected, private로 상속을 받는다면 외부에서는 부모의 멤버 변수는 private이기 때문에 접근할 수 없다 
- 상속을 받은 자식 클래스에서는 부모의 *public, protected* 접근 지정자에 접근이 가능하며, *private*에는 부모 객체에서만 접근이 가능하다
>- public : 
>	- 외부에서 부모 클래스의 public에만 접근이 가능하다
>- private :  
>	- 외부에서는 private로 되어 접근할 수 없다
>- protected : 
>	- 외부에서 protected는 접근할 수 없다
- `class test : private base` 이처럼 상속할 때는
- `base *b = test`로 부모 클래스로 업케스팅에서 오류가 발생
- 업케스팅을 하기 위해서는 상속 접근 지정자를 public로 변경해야 한다 

### Polymorphism (다형성)
- 다형성은 **같은 기능이라도 클래스마다 다른 기능을 구현할 수 있는 것**
>"휴대폰"클래스에 전화받기라는 기능을 상속받는 "갤럭시"클래스와 "아이폰"클래스가 있다고 해보자.
>기존 전화받기는 단순 전화받기 버튼을 누르는 것에 그친다면
>"갤럭시"에서는 특정 버튼을 밀어서 전화를 받는 기능을
>"아이폰"에서는 흔들어서 전화 받기 기능을 추가할 수 있다.
>이처럼 같은 부모를 둔 자식들이 각자 자신만의 기능을 구현하여 사용하는 것이 다형성
>오버로딩, 오버라이딩같은 방식을 이용하여 다형성을 구현한다


### this 포인터
>멤버 함수 내에서 자동 생성되어 현재 객체를 가리키는 포인터를 의미한다
- 지역 변수와 멤버 변수를 구분할 때
- 멤버 함수 체이닝을 사용할 때
  - 반환 형식을 레퍼런스로 해야 `.`으로 연결하여 함수를 실행한다

### 멤버 변수 초기화 방법
- 생성자 호출 시 클래스 내 멤버 변수를 초기화하는 방법
- 직접 초기화는 대입 연산자를 사용하지 않고 초기화를 시행
```cpp
public:
  // 직접 초기화 (생성자)
  Man(int x=0, int y=0) : 
  x(x),             // 일반 멤버 변수 
  y(y),
  p_y(&(this->y)),  // 멤버 포인터 변수
  location{x, y},   // 멤버 고정 배열
  number(9999),     // 멤버 상수 변수
  ref_x(x)          // 멤버 레퍼런스 변수
  {
    std::cout << "직접 초기화 방식 - 생성자(매개변수)" << std::endl;
    std::cout << "x : " << x << std::endl;
    std::cout << "y : " << y << std::endl;
    std::cout << "p_y : " << *p_y << std::endl;
    std::cout << "location(x, y) : " << location[0] << ", " << location[1] << std::endl;
    std::cout << "number : " << number << std::endl;
    std::cout << "ref_x : " << ref_x << std::endl;
  }
```
- *직접 초기화 시 순서는 나열된 순서가 아닌 클래스 내 변수가 정의된 순서대로 초기화됨*
- 복사 초기화는 `=` 값을 변수에 대입하여 사용한다.
- 어쨌든 복사가 발생하기에 직접 초기화보다는 메모리를 더 사용한다.
```cpp
// 복사 초기화
Woman(int x=0, int y=0)
{
	// this는 현재 자신의 객체를 가리키는 포인터
	// 포인터이기에 (*this).변수 or this->변수 로 사용
	this->x = x;
	this->y = y;
	
	std::cout << "복사 초기화 방식 - 일반적인 변수에 대입하듯이 작성" << std::endl;
	std::cout << "x : " << x << std::endl;
	std::cout << "y : " << y << std::endl;
}
```



### Overloading (오버로딩)
- 같은 이름의 멤버 함수이면서 매개 변수가 다르게 중복 정의 하는 것

#### Operator Overloading (연산자 오버로딩)
- +, / 과 같은 연산자를 객체끼리 사용할 수 있도록 연산자를 오버로딩하는 방법


### Overriding (오버라이딩)
- **부모의 멤버 함수의 이름을 그대로 사용하면서 재정의 하는 것**

### friend function (프렌드 함수)
- 클래스 내에 프렌트 함수를 정의하면, 프렌드 함수 내에서는 해당 클래스로 생성된 객체 정보에 접근할 수 있다

### friend class (프렌드 클래스)
- 프렌드 클래스는 한 클래스 내에서 특정 클래스를 예외적으로 접근 지정자를 무시할 수 있는 권한이다.
- 클래스 내에서 특정 클래스에 대해 `friend class 클래스이름`으로 설정하면 된다.
- 친구로 설정된 클래스에서는 해당 정보를 볼 수 있는 권한이 생긴다.
- 간단하게 특정 친구에게만 나의 정보를 볼 수 있는 권한을 주는 역할
- 캡슐화를 해칠 수 있다