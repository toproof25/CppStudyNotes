# Chapter3 포인터와 메모리 구조
1. 포인터와 메모리
2. 함수와 구조체
3. 정적 변수와 상수 변수
4. 레퍼런스 변수

### Pointer (포인터)
- 참조하는 메모리의 주소를 저장하는 변수 
- 포인터 변수 선언 `int *p_int = &int_num`
- 포인터 변수의 역참조 `*p_int == int_num`
>포인터는 C, C++에서 중요한 기능을 담당한다. 
>`int n = 5;`변수를 생성하면 컴퓨터 메모리에 저장이 된다.
>이후 n을 불러오는 것은 해당 주소를 찾아가서 값들 가져오는 행위이다.
>`int *n_pointer = &n;`이렇게 포인터를 사용하게 되면은 해당 메모리의 ***주소***를 저장하는 변수로 설정된다. 그리고 모든 포인터는 ***8byte***의 크기를 가지게 된다.
>변수 n의 메모리 주소가 1000이라면, &n의 값은 1000이고, 포인터 \*n_pointer는 또 다른 메모리에 **8byte**만큼 공간을 차지하며, n의 주소를 참조하는 포인터 변수로 지정된다. 

### 포인터 변수 사용 시 중요한 점
>- #### 포인터 역참조시 가리키는 참조 주소가 유효한 지 상태를 확인
>	- `int *n = &a`라면 역참조 -> \*n일때 포인터 주소를 확인 (세그멘테이션 실패)
>- #### 할당된 메모리를 벗어나는 연산을 피하자
>	- 배열 크기 5인 변수에 6을 참조하는 등의 연산을 피해야한다.
>- #### 할당 해제된 메모리를 역참조하지 말자 


### const Pointer (포인터 상수)
- `const int *p_num = &number`
- 포인터 자체는 상수가 아니지만, 가리키는 값을 상수화 하였기에 값을 변경할 수 없다
- `*p_num = 9999` -> 상수 변경 오류가 발생
- 하지만 number변수는 상수가 아니기에 number을 변경하면 값은 변경된다


### Fixed Array (고정 배열)
- C++에서 배열은 `자료형 변수명[배열 크기] = {인덱스0, 인덱스1, 인덱스...}`를 통해 선언할 수 있다. 이렇게 선언한 배열은 고정되어 있어 동적으로 크기를 할당할 수는 없다.
- 배열과 포인터는 근접한 관계를 가지고 있는데 배열의 변수명을 그대로 쓰면 배열의 0번째 위치에 를 가리킨다. 이는 포인터를 통해 배열에 접근할 수 있다는 의미.
- 배열의 크기는 `배열 전체 크기 = 배열 크기*자료형`이며, 포인터를 통해 n+1... n+2로 접근할 때는 더해지는 피연산자에 자료형만큼 더해져서 주소에 접근한다. `n+1  -->  n + 1*자료형`

### Struct (구조체)
- 변수, 함수 등을 하나의 이름으로 그룹화 한 것
- `struct 구조체 이름` 으로 선언할 수 있다.
```cpp
struct Person{
	std::string name;
	int age;
	float height;
	float weight;
}
```
>구조체는 변수를 묶어서 전달하거나 관리할 수 있기에 함수의 피라미터로 넘기거나 할 때 간단하게 적용할 수 있는 장점이 있다. 이외에도 같은 변수들이 반복되면서 각자 다른 값을 가져야 할 경우에도 구조체는 매우 유용하게 사용할 수 있다고 생각한다.

### Reference Value (레퍼런스 변수)
- 레퍼런스 변수는 A라는 변수의 주소를 가리키는 변수이다. 변수의 별명이기도 하며, 레퍼런스 변수는 참조하는 변수에 대해 똑같이 사용하게 된다.
- `int &ref_num = num;`
- 위 처럼 변수의 주소를 할당받게 되며, 레퍼런스 변수는 기존의 변수처럼 사용할 수 있다.
- 즉 포인터 변수를 통해 주소를 참조하여 값을 바꾸는 작업을 간단하게 하여 변수의 주소를 통해 값을 설정할 수 있게 된다.
- 주로 함수 피라미터로 자주 사용된다고 한다.
##### 레퍼런스 변수 주의사항
>- 레퍼런스 변수는 NULL값을 가질 수 없으며, 초기화를 할 때 값을 선언해야한다.
>- 주소 연산이 불가능하다
>- 한번 설정된 변수 말고는 다른 변수를 참조할 수 없다



### Call by Value, Call by Reference, Call by Adress
-함수 파라미터로 넘어온 값이 말 그대로 "값"인 경우이다.
-아래의 경우 들어온 num1, num2의 값은 복사되어 swap함수 내에 지역변수로 사용이 된다.
-그렇기에 원본 변수는 변경되지 않고, 복사된 지역 변수끼리 변환이 된다
```cpp
// Call by Value - 값을 복사하여 해당 함수내에 지역변수로 바뀜 - 원본은 안바뀜
void swap(int num1, int num2)
{
    int temp = num1;
    num1 = num2;
    num2 = temp;
}
```
- 함수 파라미터로 넘어온 값의 주소를 받아서 사용하는 함수
- 원본 값의 주소를 받기 때문에 원본 변수의 값을 직접적으로 제어할 수 있다.
- 직접 참조를 통해 값을 변경할 수 있다.
```cpp
// Call by Reference - 값의 주소 자체를 받아와서 해당 주소의 값을 바꿈 - 원본도 바뀜
void ref_swap(int &ref_num1, int &ref_num2)
{
    int temp = ref_num1;
    ref_num1 = ref_num2;
    ref_num2 = temp;
}
```
- 포인터 변수를 통해 스택 메모리 주소를 가져와서 역참조로 값을 변경하는 방식
```cpp
// Call by Adress - 값의 주소를 포인터 변수로 받아와서 해당 주소의 값을 바꿈 - 원본도 바뀜
void p_swap(int *num1, int *num2)
{
    int temp = *num1;
    *num1 = *num2;
    *num2 = temp;
}
```

